---
type: prog22
section: funktionale programmierung
nr: 4
title: Funktionen höherer Ordnung & Typpolymorphie
date: 02.05. bis 06.05.2022
---

<ul class="fa-ul">
  <li>
    <i class="fa-li fa fa-pen"></i>
    <a
      href="https://www.orchid.inf.tu-dresden.de/teaching/2022ss/prog/tut04.pdf"
      target="_blank"
      >Übungsblatt 4</a
    >
  </li>

  <li>
    <i class="fa-li fa fa-edit"></i>
    <div style="text-align: left">
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut04/tut04-slides.pdf"
        class="button primary"
        >Slides</a
      >
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut04/tut04-handout.pdf"
        class="button"
        >Handout</a
      >
      <a
        style="margin-left: 2em"
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut04/tut04-all.hs"
        target="_blank"
        class="button icon solid fa-download"
        >Code</a
      >
    </div>
  </li>
  <li style="margin-left: -6pt">
    <i class="fa-li fa fa-edit" style="margin-left: 6pt"></i>
    <details>
      <summary class="inline">Lösungen</summary>
      <ul class="aufgabenloesungen">
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 1</summary>
            <p style="text-align: justify">
              Produkt der Quadratzahlen aller geraden Elemente einer Liste
            </p>
            <pre><code><!--
  -->f :: [Int] -> Int
f xs = foldr product 1 (map square (filter even' xs))
  where
    even' x = mod x 2 == 0
    square x = x * x
    product x y = x * y

f' :: [Int] -> Int
f' xs = foldr (*) 1 (map (^2) (filter even xs))

f'' :: [Int] -> Int
f'' = foldr (*) 1 . map (^2) . filter even

f''' :: [Int] -> Int
f''' = foldr (*) 1 . map (^2) . filter ((== 0) . (`mod` 2))<!--
                --></code></pre>
            <p style="text-align: justify">
              Hinweise: In Haskell werden Funktionen, die in Infix (also
              zwischen den Argumenten, z.B. <code>+</code>, <code>-</code>,
              <code>/</code>, <code>==</code>, <code>&&</code>) benutzt werden,
              in Klammern notiert (z.B. <code>(+) :: Int -> Int -> Int</code>).
              D.h. Operatoren werden wie alle anderen Funktionen behandelt, wenn
              man sie klammert, z.B. in <code>(+) 2 1 == 3</code>. Andere
              Funktionen können auch Infix benutzt werden, indem sie durch
              Backticks <code>`...`</code> umgeben werden, z.B.
              <code>5 `mod` 2 == 1</code> statt <code>mod 5 2 == 1</code>.
              Mittels partieller Applikation kann man bei Infixfunktionen einen
              Wert an den zweiten (rechten) Operanden binden, so ist
              <code>`mod` 2</code> beispielsweise eine Funktion, die für alle
              Eingabewerte den Restbetrag der Division durch 2 berechnet. Der
              Operator <code>.</code> ist die Funktionskomposition, also
              berechet <code>(== 0) . (`mod` 2)</code> zuerst den Restbetrag der
              Division durch 2 und testet diesen Wert dann der Gleichheit mit 0.
              Die entstehende Funktion gibt also genau für alle geraden
              Eingabewerte den Wert <code>True</code>
              zurück.
            </p>
            <iframe
              width="560"
              height="315"
              src="https://www.youtube.com/embed/aPrAR20sWFs"
              title="YouTube video player"
              frameborder="0"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen
            ></iframe>
          </details>
        </li>

        <li>
          <details>
            <summary class="aufgabe">Aufgabe 2</summary>
            <p style="text-align: justify">Liste von links falten</p>
            <pre><code><!--
                -->foldleft :: (Int -> Int -> Int) -> Int -> [Int] -> Int
foldleft f x []     = x
foldleft f x (y:ys) = foldleft f (f x y) ys<!--
                --></code></pre>
            <p style="text-align: justify">
              Die Funktion ist als <code>foldl</code> in der Standarbibliothek
              Prelude enthalten.
            </p>
            <iframe
              width="560"
              height="315"
              src="https://www.youtube.com/embed/MELbgreKyug"
              title="YouTube video player"
              frameborder="0"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen
            ></iframe>
          </details>
        </li>

        <li>
          <details>
            <summary class="aufgabe">Aufgabe 3</summary>
            <ol>
              <li>
                Beispielbaum
                <pre><code><!--
-->mytree :: Tree Char
mytree = Node ’a’ [ 
            Node ’b’ [ Node ’c’ [], Node ’d’ [] ] ,
            Node ’e’ [ Node ’f’ [] ],
            Node ’g’ []
          ]<!--
            --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/oHSZ0FvPcV0"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Baum auf ungerade Anzahl an Kindern testen
                <pre><code><!--
-->oddTree :: Tree a -> Bool
oddTree (Node _ []) = True
oddTree (Node _ ts) = oddTrees ts && (length ts ‘mod‘ 2 == 1)
  where 
    oddTrees :: [Tree a] -> Bool
    oddTrees []       = True
    oddTrees (t : ts) = oddTree t && oddTrees ts<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/bE9zm9vS9PU"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Pre-Order-Traversierung
                <pre><code><!--
-->preOrder :: Tree a -> [a]
preOrder (Node x ts) = x : preOrderTrees ts
  where
    preOrderTrees []       = []
    preOrderTrees (t : ts) = preOrder t ++ preOrderTrees ts
  
-- alternativ mit Prelude:
preOrder :: Tree a -> [a]
preOrder (Node x ts) = x : concatMap preOrder ts<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/W2dHIQNedw8"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
            </ol>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>
