---
type: prog22
section: funktionale programmierung
nr: 2
title: Listen
date: 19.04. bis 22.04.2022
---

<ul class="fa-ul">
  <li>
    <i style="color: #f69200" class="fa-li fa fa-exclamation-triangle"></i>
    <div style="text-align: justify">
      Die Montag-Übung am 18.04.2022 findet wegen des Ostermontags nicht statt.
      Die Übung wird für diese Gruppe stattdessen am Mittwoch, dem 20.04.2022
      von 13 Uhr bis 14.30 Uhr (4. Doppelstunde) im Georg-Schumann-Bau Raum
      SCH/A419 abgehalten.
    </div>
  </li>
  <li>
    <i class="fa-li fa fa-pen"></i>
    <a
      href="https://www.orchid.inf.tu-dresden.de/teaching/2022ss/prog/tut02.pdf"
      target="_blank"
      >Übungsblatt 2</a
    >
  </li>

  <li>
    <i class="fa-li fa fa-edit"></i>
    <div style="text-align: left">
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut02/tut02-slides.pdf"
        class="button primary"
        >Slides</a
      >
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut02/tut02-handout.pdf"
        class="button"
        >Handout</a
      >
      <a
        style="margin-left: 2em"
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut02/tut02-all.hs"
        target="_blank"
        class="button icon solid fa-download"
        >Code</a
      >
    </div>
  </li>
  <li style="margin-left: -6pt">
    <i class="fa-li fa fa-edit"></i>
    <details>
      <summary class="inline">Lösungen</summary>
      <ul class="aufgabenloesungen">
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 1</summary>
            <p style="text-align: justify">
              Wir berechnen den Binomialkoeffizienten \(\binom{n}{k} =
              \frac{n!}{k! \ (n-k)!}\). Man beachte dabei, dass die
              Integer-Division in Haskell mit der Funktion
              <code>div</code> erfolgen muss. Man kann die Funktion durch
              <code>`div`</code> auch in Infixnotation zwischen die Operanten
              schreiben.
            </p>
            <pre><code><!--
-->bincoeff :: Int -> Int -> Int
bincoeff n k = fac n ‘div‘ (fac (n-k) * fac k)
    where
        fac n
            | n < 1     = 1
            | otherwise = n * fac (n-1)<!--
            --></code></pre>
          </details>
        </li>
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 2</summary>
            <ol>
              <li>
                Produkt einer Liste
                <pre><code><!--
-->prod :: [Int] -> Int
prod []     = 1
prod (x:xs) = x * prod xs<!--
                                        --></code></pre>
              </li>
              <li>
                eine Liste umkehren
                <pre><code><!--
-->rev :: [Int] -> [Int]
rev [] = []
rev (x:xs) = rev xs ++ [x]<!--
                                        --></code></pre>
              </li>
              <li>
                Elemente einer Liste löschen
                <pre><code><!--
-->excl :: Int -> [Int] -> [Int]
excl _  []    = []
excl y (x:xs)
    | x == y    = excl y xs
    | otherwise = x : excl y xs<!--
                                        --></code></pre>
              </li>
              <li>
                Sortierung einer Liste prüfen
                <pre><code><!--
-->isOrd' :: [Int] -> Bool
isOrd' [] = True
isOrd' [x] = True
isOrd' (x:y:xs) = x <= y && isOrd' (y:xs)<!--
                                        --></code></pre>
              </li>
              <li>
                (sortierte) Listen zusammenfügen
                <pre><code><!--
-->merge :: [Int] -> [Int] -> [Int]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
  | x < y = x : merge xs (y:ys)
  | otherwise = y : merge (x:xs) ys<!--
                                        --></code></pre>
              </li>
              <li>
                (unendliche) Liste der Fibonacci-Zahlen
                <pre><code><!--
-->fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

fib' :: Int -> Int
fib' i = stack 1 1 i
    where 
        stack f0 f1 0 = f0
        stack f0 f1 i = stack f1 (f0 + f1) (i-1)

fibs :: [Int]
fibs = fibAppend 0
where fibAppend x = fib x : fibAppend (x+1)

fibs' :: [Int]
fibs' = fib_stack 1 1
    where
      fib_stack x y =  x : fib_stack y (x+y)<!--
                                        --></code></pre>
                Testen kann man diese Funktion beispielsweise mittels
                <code>take 7 fibs</code>, was uns die ersten sieben
                Fibonacci-Zahlen zurückgibt. <code>take</code> ist dabei eine
                Funktion aus der Standard-Bibliothek <code>Prelude</code> vom
                Typ <code>take :: Int -> [Int] -> [Int]</code>, siehe auch
                <a
                  href="http://zvon.org/other/haskell/Outputprelude/take_f.html"
                  >hier</a
                >. Man kann nun zwischen den beiden Varianten
                <code>fibs</code> und <code>fibs'</code> umschalten und die
                Laufzeitunterschiede vergleichen.
              </li>
            </ol>
          </details>
        </li>
        <li>
          <details>
            <summary class="aufgabe">Zusatzaufgabe</summary>
            <p style="text-align: justify">
              Die Collatz-Folge ist eine relativ einfach definierte Folge, deren
              Verhalten aber erstaunlich wenig erforscht ist. Die sogenannte
              Collatz-Vermutung geht davon aus, dass - egal welchen Startwert
              man wählt - man irgendwann stets in einen Zyklus \( 1 \to 4 \to 2
              \to 1\) kommt. Dementsprechend sind wir in dieser Aufgabe auf der
              Suche nach dem Index, für den wir in diesen Zyklus einsteigen.
              Mehr Informationen erfahrt ihr in folgendem Video.
            </p>
            <iframe
              width="560"
              height="315"
              src="https://www.youtube.com/embed/094y1Z2wpJg"
              title="YouTube video player"
              frameborder="0"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen
            ></iframe>
            <pre><code><!--
-->cnext :: Int -> Int
cnext n
    | n `mod` 2 == 0 = n `div` 2
    | otherwise      = 3 * n + 1

ck :: Int -> Int
ck 1 = 1
ck n = 1 + ck (cnext n)

cmax :: Int -> Int
cmax 0 = 0
cmax n = max (cmax (n-1)) (ck n) -- oder cmax (n-1) ‘max‘ ck n
    where max a b
        | a > b     = a
        | otherwise = b

collatz :: Int -> [Int]
collatz 1 = [1]
collatz n = n : collatz (cnext n)<!--
            --></code></pre>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>
