---
type: prog22
section: funktionale_programmierung
nr: 1
title: Einführung in Haskell
date: 11.04. bis 15.04.2022
---

<ul class="fa-ul">
  <li>
    <i class="fa-li fa fa-pen"></i>
    <a
      href="https://www.orchid.inf.tu-dresden.de/teaching/2022ss/prog/tut01.pdf"
      target="_blank"
      >Übungsblatt 1</a
    >
  </li>

  <li>
    <i class="fa-li fa fa-edit"></i>
    <div style="text-align: left">
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01-slides.pdf"
        class="button primary"
        >Slides</a
      >
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01-handout.pdf"
        class="button"
        >Handout</a
      >
    </div>
  </li>

  <li style="margin-left: -6pt">
    <i class="fa-li fa fa-edit"></i>
    <details>
      <summary class="inline">Lösungen</summary>
      <ul class="aufgabenloesungen">
        <li><strong>Aufgabe 1</strong>: siehe Slides</li>
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 2</summary>
            <p style="text-align: justify">
              Wir berechnen die Fakultät \(n! = \prod_{i=1}^n i\).
            </p>
            <pre><code><!--
  -->-- Aufgabe 2(a)
fac :: Int -> Int
fac 0 = 1
fac n = n * fac (n-1)<!--
      --></code></pre>
            <p style="text-align: justify">
              Wir summieren Fakultäten auf, d.h. berechnen
              \(\operatorname{sumFacs}(n,m) = \sum_{i=n}^m i!\). Dabei können
              wir wahlweise die obere Grenze oder die untere Grenze
              "rausziehen".
            </p>
            <pre><code><!--
  -->-- Aufgabe 2(b)
sumFacs :: Int -> Int -> Int
sumFacs n m
  | n > m = 0
  | otherwise = fac n + sumFacs (n+1) m

sumFacs' :: Int -> Int -> Int
sumFacs' n m
  | n > m = 0
  | otherwise = fac m + sumFacs' n (m-1)<!--
      --></code></pre>
          </details>
        </li>
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 3</summary>
            <p style="text-align: justify">
              Wir berechnen die Fibonacci-Zahlen und nutzen dafür die bereits
              gegebene Rekursionsvorschrift \(f_n = f_{n-1} + f_{n-2}\) mit den
              Startwerten \(f_0 = 1\) und \(f_1 = 1\).
            </p>
            <pre><code><!--
  -->fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)<!--
      --></code></pre>
            <p style="text-align: justify">
              Wenn man mittels <code>:set +s</code> die Laufzeitmessung in GHCi
              aktiviert und <code>fib n</code> für große <code>n</code> versucht
              zu berechnen, wird man feststellen, dass das sehr lange dauert.
              Daher kann man eine alternative Variante implementieren, die drei
              "Speicherplätze" nutzt und somit ein iteratives Verfahren nachahmt
              (vgl. Slides).
            </p>
            <pre><code><!--
  -->fib' :: Int -> Int
fib' n = fib_help 1 1 n

fib_help :: Int -> Int -> Int -> Int
fib_help x _ 0 = x
fib_help x y n = fib_help y (x+y) (n-1)<!--
      --></code></pre>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>
