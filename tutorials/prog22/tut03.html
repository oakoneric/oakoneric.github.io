---
type: prog22
section: funktionale programmierung
nr: 3
title: Zeichenketten & Bäume
date: 25.04. bis 29.04.2022
---

<ul class="fa-ul">
  <li>
    <i class="fa-li fa fa-pen"></i>
    <a
      href="https://www.orchid.inf.tu-dresden.de/teaching/2022ss/prog/tut03.pdf"
      target="_blank"
      >Übungsblatt 3</a
    >
  </li>

  <li>
    <i class="fa-li fa fa-edit"></i>
    <div style="text-align: left">
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut03/tut03-slides.pdf"
        class="button primary"
        >Slides</a
      >
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut03/tut03-handout.pdf"
        class="button"
        >Handout</a
      >
      <a
        style="margin-left: 2em"
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss22/tut03/tut03-all.hs"
        target="_blank"
        class="button icon solid fa-download"
        >Code</a
      >
    </div>
  </li>
  <li style="margin-left: -6pt">
    <i class="fa-li fa fa-edit" style="margin-left: 6pt"></i>
    <details>
      <summary class="inline">Lösungen</summary>
      <ul class="aufgabenloesungen">
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 1</summary>
            <ol>
              <li>
                Präfix-Test
                <pre><code><!--
  -->isPrefix :: String -> String -> Bool
isPrefix [] _ = True
isPrefix _ [] = False
isPrefix (p:ps) (c:cs) = p == c && isPrefix ps cs<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/SSJfQhxnpEI"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Vorkommen eines Patterns zählen
                <pre><code><!--
                -->countPattern :: String -> String -> Int
countPattern "" "" = 1
countPattern _  "" = 0
countPattern ps ccs@(c:cs)
    | isPrefix ps ccs = 1 + countPattern ps cs
    | otherwise       = countPattern ps cs<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/kU37judL4q8"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
            </ol>
          </details>
        </li>
        <li>
          <details>
            <summary class="aufgabe">Aufgabe 2</summary>
            <ol>
              <li>
                Beispielbaum
                <pre><code><!--
-->mytree :: BinTree
mytree = Branch 0 
          ( Nil )
          ( Branch 3 
            ( Branch 1 Nil Nil )
            ( Branch 5 Nil Nil )
          )<!--
            --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/D8wWhfb687Y"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Test auf Baumgleichheit
                <pre><code><!--
-->equal :: BinTree -> BinTree -> Bool
equal Nil              Nil              = True
equal Nil              (Branch y l2 r2) = False
equal (Branch x l1 r1) Nil              = False
equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && (equal l1 l2) && (equal r1 r2)<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/RQPeEj2YoXE"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Schlüssel in einen (Such-)Baum einfügen
                <pre><code><!--
-->insert :: BinTree -> [Int] -> BinTree
insert t     [] = t
insert t (n:ns) = insert t' ns
  where
    t' = insertSingle t n
    insertSingle Nil            n = Branch n Nil Nil
    insertSingle (Branch x l r) n
      | n < x     = Branch x (insertSingle l n) r
      | otherwise = Branch x l                  (insertSingle r n)<!--
                                        --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/SSAOrhtWiWE"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
              <li>
                Levelorder-Traversierung
                <pre><code><!--
-->unwind :: BinTree -> [Int]
unwind t = go [t]
  where
      go []                  = []
      go ( Nil           : ts) = go ts
      go ((Branch x l r) : ts) = x : go (ts ++ [l,r])<!--
                --></code></pre>
                <iframe
                  width="560"
                  height="315"
                  src="https://www.youtube.com/embed/CxpA99ZhAZc"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowfullscreen
                ></iframe>
              </li>
            </ol>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>
