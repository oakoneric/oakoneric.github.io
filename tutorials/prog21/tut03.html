---
type: prog21
nr: 3
title: Haskell - Funktionen höherer Ordnung
date: 26.04. bis 30.04.2021

ue-blatt: https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/tut03.pdf
templates: https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_templates.zip

slides: https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03.pdf
handout: https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_handout.pdf
code: https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_code.zip

vl-video: https://www.orchid.inf.tu-dresden.de/videos/e-learning/prog-03-98799wX6.mp4
ue-video: https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut03-mi.mp4
---

<li>
  <ul>
    <li>
      ausführliche Erklärung zu
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_higherOrderFunctions.pdf"
        >Funktionen höherer Ordnung</a
      >
      incl. Erklärung zu Aufgaben 2 und 3
    </li>
    <li>
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut03-aufgabe3.mp4"
        target="_blank"
        >Video zu Aufgabe 3</a
      >
      (<code>foldleft</code>-Funktion)
    </li>
    <li>
      Slides mit Anmerkungen vom
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_notes_di.pdf"
        >Dienstag</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_notes_mi.pdf"
        >Mittwoch</a
      >
    </li>
  </ul>
</li>

<li>
  <i class="fa-li fa fa-edit"></i>
  <details>
    <summary class="inline">Lösungen</summary>

    <ul>
      <li>
        <strong>Aufgabe 1</strong>: Bäume mit beliebig vielen Kindern -
        <code>data RoseTree = Node Int [RoseTree]</code>
        <ol>
          <li>
            Anzahl der Blätter zählen:
            <pre><code><!--
-->countLeaves :: RoseTree -> Int
countLeaves (Node _ [] )    = 1
countLeaves (Node _ [t])    = countLeaves t
countLeaves (Node x (t:ts)) = countLeaves t + countLeaves (Node x ts)<!--
                        --></code></pre>
          </li>
          <li>
            Prüfen, ob ein RoseTree immer eine gerade Anzahl an Kindern hat
            <br />
            <p style="text-align: justify">
              Variante 1: durch Abspalten von immer zwei Bäumen aus der Liste
              können wir am Ende feststellen, ob die Liste gerade Länge (es
              bleibt <code>[]</code> übrig) oder ungerade Länge (es bleibt eine
              einelementige Liste <code>[t]</code> übrig) hatte
            </p>
            <pre><code><!--
-->evenNodes :: RoseTree -> Bool
evenNodes (Node _  []       ) = True
evenNodes (Node x  [t]      ) = False
evenNodes (Node x (t1:t2:ts)) = evenNodes (Node x ts) && evenNodes t1 && evenNodes t2<!--
                        --></code></pre>
            <p style="text-align: justify">
              Variante 2: Wir prüfen explizit, ob die Länge der Liste gerade ist
              (mittels <code>length</code>-Funktion) und testen das erste
              Listenelement mit <code>evenNodes'</code>, die
              <code>RoseTree</code> verarbeiten kann, sowie die Restliste mit
              einer Funktion <code>evenNodes''</code>, die Listen
              <code>[RoseTree]</code> verarbeiten kann.
            </p>
            <pre><code><!--
-->evenNodes' :: RoseTree -> Bool
evenNodes' (Node _ []) = True
evenNodes' (Node _ ts) = mod (length ts) 2 == 0 && evenNodes'' ts
where
evenNodes'' :: [RoseTree] -> Bool
evenNodes'' []     = True
evenNodes'' (t:ts) = evenNodes' t && evenNodes'' ts<!--
                        --></code></pre>
          </li>
        </ol>
      </li>
      <li>
        <strong>Aufgabe 2:</strong> Funktionen höherer Ordnung
        <p style="text-align: justify">
          Für diese Aufgabe gibt es viele verschiedene Varianten, ich erwähne
          hier nur einige davon. Entgegen meiner Behauptung in den Übungen
          benötigt man natürlich beim Filtern der geraden Zahlen keine
          <code>length</code>-Funktion; da hab ich mich von den
          <code>evenNodes</code> von oben verwirren lassen ;)
        </p>
        <pre><code><!--
-->f :: [Int] -> Int
f xs = foldr product 1 (map square (filter even' xs))
where even' x = mod x 2 == 0
square x = x * x
product x y = x * y

f' :: [Int] -> Int
f' xs = foldr (*) 1 (map (^2) (filter even xs))

f'' :: [Int] -> Int
f'' = foldr (*) 1 . map (^2) . filter even

f''' :: [Int] -> Int
f''' = foldr (*) 1 . map (^2) . filter ((== 0) . (`mod` 2))<!--
                --></code></pre>
      </li>
      <li>
        <strong>Aufgabe 3:</strong> Faltung einer Liste von links
        <pre><code><!--
-->foldleft :: (Int -> Int -> Int) -> Int -> [Int] -> Int
foldleft f x []     = x
foldleft f x (y:ys) = foldleft f (f x y) ys<!--												
                --></code></pre>
      </li>
    </ul>
  </details>
</li>
