<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title> Testpage  </title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	</head>

	<body class="is-preload">

		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Main -->
			<div id="main">
				<div class="inner">

					<!-- Header -->
					<header id="header">
    <a href="index.html" class="logo"><strong>Tutorials</strong> by Eric Kunze</a>
    <ul class="icons">
        <li><a href="index.html" class="icon solid fa-home"><span class="label">Home</span></a></li>
        <li><a href="mailto:eric.kunze@mailbox.tu-dresden.de" class="icon solid fa-envelope"><span class="label">Mail</span></a></li>
        <li><a href="https://github.com/oakoneric/" class="icon brands fa-github"><span class="label">Github</span></a></li>
        <li><a href="https://www.instagram.com/oakoneric/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
        <li><a href="https://t.me/oakoneric" class="icon brands fa-telegram"><span class="label">Telegram</span></a></li>
    </ul>
</header>

					<!-- Content -->
					<!-- Content -->
<section>
  <header>
    <div class="title">Title</div>
    <div class="subtitle">Untertitle</div>
  </header>

  <h2>Überschrift 2</h2>

  Das hier wird noch zu einer Liste werden:
  <ul>
    <li>Grundlagen der funktionalen Programmierung in Haskell</li>
    <li>Unifikationsalgorithmus</li>
    <li>Beweis von Programmeigenschaften mit struktureller Induktion</li>
    <li>Lambda-Kalkül</li>
    <li>Logikprogrammierung in Prolog</li>
    <li>Abstrakte Maschinen AM0 und AM1 sowie deren Übersetzung von/nach C</li>
    <li>Beweis von Programmeigenschaften mit dem Hoare-Kalkül</li>
    <li>Abstrakte Maschinen mit Haskell</li>
  </ul>

  <h2>Überschrift 2</h2>
  <p>
    Hier steht unter anderem auch ein
    <a href="https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/">Link</a
    >.
  </p>

  <h2>Übungen</h2>

                             
  <details>
    <summary>
      <div class="title">Woche 1: Einführung in Haskell</div>
      <div class="subtitle">12.04. bis 16.04.2021</div>
    </summary>

    <div class="exercise-content">
      <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/videos/e-learning/prog-01-nz1wPQ5M.mp4" target="_blank">Vorlesungsvideo</a>
        </li>

        <li>
          <i class="fa-li fa fa-pen"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/tut01.pdf" target="_blank">Übungsblatt 1</a>
        </li>

        

        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut01-di.mp4" target="_blank">
            Videoaufzeichnung der Übung
          </a>
        </li>

        <li>
          <i class="fa-li fa fa-edit"></i>
          <div style="text-align: left">
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01.pdf" class="button primary">Slides</a>
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01_handout.pdf" class="button">Handout</a>

             &nbsp;&nbsp;&nbsp;
            <a
              href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01_code.zip"
              target="_blank"
              class="button icon solid fa-download"
            >
              Code
            </a>
            
          </div>
        </li>

        <li>
  <ul>
    <li>
      Slides mit Anmerkungen vom
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01_notes_di.pdf"
        >Dienstag</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut01/tut01_notes_mi.pdf"
        >Mittwoch</a
      >
    </li>
  </ul>
</li>
<li>
  <i class="fa-li fa fa-edit"></i>
  <details>
    <summary class="inline">Lösungen</summary>

    <ul>
      <li><strong>Aufgabe 1</strong>: siehe Slides</li>
      <li>
        <strong>Aufgabe 2</strong>
        <p style="text-align: justify">
          Wir berechnen die Fakultät \(n! = \prod_{i=1}^n i\).
        </p>
        <pre><code><!--
-->-- Aufgabe 2(a)
fac :: Int -> Int
fac 0 = 1
fac n = n * fac (n-1)<!--
    --></code></pre>
        <p style="text-align: justify">
          Wir summieren Fakultäten auf, d.h. berechnen
          \(\operatorname{sumFacs}(n,m) = \sum_{i=n}^m i!\). Dabei können wir
          wahlweise die obere Grenze oder die untere Grenze "rausziehen".
        </p>
        <pre><code><!--
-->-- Aufgabe 2(b)
sumFacs :: Int -> Int -> Int
sumFacs n m
| n > m = 0
| otherwise = fac n + sumFacs (n+1) m

sumFacs' :: Int -> Int -> Int
sumFacs' n m
| n > m = 0
| otherwise = fac m + sumFacs' n (m-1)<!--
    --></code></pre>
      </li>
      <li>
        <strong>Aufgabe 3</strong>
        <p style="text-align: justify">
          Wir berechnen die Fibonacci-Zahlen und nutzen dafür die bereits
          gegebene Rekursionsvorschrift \(f_n = f_{n-1} + f_{n-2}\) mit den
          Startwerten \(f_0 = 1\) und \(f_1 = 1\).
        </p>
        <pre><code><!--
-->fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

fib' :: Int -> Int
fib' n = fib_help 1 1 n

fib_help :: Int -> Int -> Int -> Int
fib_help x _ 0 = x
fib_help x y n = fib_help y (x+y) (n-1)<!--
    --></code></pre>
        <p style="text-align: justify">
          Wenn man mittels <code>:set +s</code> die Laufzeitmessung in GHCi
          aktiviert und <code>fib n</code> für große <code>n</code> versucht zu
          berechnen, wird man feststellen, dass das sehr lange dauert. Daher
          kann man eine alternative Variante implementieren, die drei
          "Speicherplätze" nutzt und somit ein iteratives Verfahren nachahmt
          (vgl. Slides).
        </p>
        <pre><code><!--
-->fib' :: Int -> Int
fib' n = fib_help 1 1 n

fib_help :: Int -> Int -> Int -> Int
fib_help x _ 0 = x
fib_help x y n = fib_help y (x+y) (n-1)<!--
    --></code></pre>
      </li>
    </ul>
  </details>
</li>

      </ul>
    </div>
  </details>
    
  <details>
    <summary>
      <div class="title">Woche 2: Haskell - Datentypen</div>
      <div class="subtitle">19.04. bis 23.04.2021</div>
    </summary>

    <div class="exercise-content">
      <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/videos/e-learning/prog-02-6bu0v044.mp4" target="_blank">Vorlesungsvideo</a>
        </li>

        <li>
          <i class="fa-li fa fa-pen"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/tut02.pdf" target="_blank">Übungsblatt 2</a>
        </li>

        
        <li>
          <i class="fa-li fa fa-code"></i>
          <a href="tut.templates"
            >Coding Templates <span class="icon solid fa-download"></span
          ></a>
        </li>
        

        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut02-mi.mp4" target="_blank">
            Videoaufzeichnung der Übung
          </a>
        </li>

        <li>
          <i class="fa-li fa fa-edit"></i>
          <div style="text-align: left">
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02.pdf" class="button primary">Slides</a>
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02_handout.pdf" class="button">Handout</a>

             &nbsp;&nbsp;&nbsp;
            <a
              href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02_code.zip"
              target="_blank"
              class="button icon solid fa-download"
            >
              Code
            </a>
            
          </div>
        </li>

        <li>
  <ul>
    <li>
      ausführliche Erklärung zu
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02_aufgabe3.pdf"
        >Aufgabe 3</a
      >
    </li>
    <li>
      Slides mit Anmerkungen vom
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02_notes_di.pdf"
        >Dienstag</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut02/tut02_notes_mi.pdf"
        >Mittwoch</a
      >
    </li>
  </ul>
</li>

<li>
  <i class="fa-li fa fa-edit"></i>
  <details>
    <summary class="inline">Lösungen</summary>

    <ul>
      <li>
        <strong>Aufgabe 1</strong>: Listenoperationen
        <ol>
          <li>
            eine Liste umkehren
            <pre><code><!--
-->rev :: [Int] -> [Int]
rev [] = []
rev (x:xs) = rev xs ++ [x]<!--
                                    --></code></pre>
          </li>
          <li>
            Sortierung einer Liste prüfen
            <pre><code><!--
-->isOrd' :: [Int] -> Bool
isOrd' [] = True
isOrd' [x] = True
isOrd' (x:y:xs) = x <= y && isOrd' (y:xs)<!--
                                    --></code></pre>
          </li>
          <li>
            (sortierte) Listen zusammenfügen
            <pre><code><!--
-->merge :: [Int] -> [Int] -> [Int]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
| x < y = x : merge xs (y:ys)
| otherwise = y : merge (x:xs) ys<!--
                                        --></code></pre>
          </li>
          <li>
            (unendliche) Liste der Fibonacci-Zahlen
            <pre><code><!--
-->fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

fib' :: Int -> Int
fib' i = stack 1 1 i
where stack f0 f1 0 = f0
stack f0 f1 i = stack f1 (f0 + f1) (i-1)

fibs :: [Int]
fibs = fibAppend 0
where fibAppend x = fib x : fibAppend (x+1)<!--
                                    --></code></pre>
            Testen kann man diese Funktion beispielsweise mittels
            <code>take 7 fibs</code>, was uns die ersten sieben Fibonacci-Zahlen
            zurückgibt. <code>take</code> ist dabei eine Funktion aus der
            Standard-Bibliothek <code>Prelude</code> vom Typ
            <code>take :: Int -> [Int] -> [Int]</code>, d.h. man kann mit dieser
            Funktion nicht ein Intervall von gewünschten Zahlen angeben (wie
            eine Frage in der Übung war), siehe auch
            <a href="http://zvon.org/other/haskell/Outputprelude/take_f.html"
              >hier</a
            >. Man kann nun zwischen den beiden Varianten <code>fib</code> und
            <code>fib'</code> umschalten und die Laufzeitunterschiede (vgl. auch
            Übung 1, Aufgabe 3) vergleichen.
          </li>
        </ol>
      </li>
      <li>
        <strong>Aufgabe 2:</strong> Zeichen & Zeichenketten
        <ol>
          <li>
            Präfix-Test - Wir testen ob ein String Präfix eines weiteren Strings
            ist.
            <pre><code><!--
-->isPrefix :: String -> String -> Bool
isPrefix [] _ = True
isPrefix _ [] = False
isPrefix (p:ps) (c:cs) = p == c && isPrefix ps cs<!--
                                    --></code></pre>
          </li>
          <li>
            Wir testen das Vorkommen eines Patterns in einem gegebenen String.
            <pre><code><!--
-->countPattern :: String -> String -> Int
countPattern "" "" = 1
countPattern _  "" = 0
countPattern xs yys@(y:ys)
| isPrefix xs yys = 1 + countPattern xs ys
| otherwise       = countPattern xs ys <!--
                                    --></code></pre>
          </li>
        </ol>
      </li>
      <li>
        <strong>Aufgabe 3:</strong> algebraische Datentypen
        <ol>
          <li>
            Beispielbaum
            <pre><code><!--
-->mytree :: BinTree
mytree = Branch 0 
( Nil )
( Branch 3 
( Branch 1 Nil Nil )
( Branch 5 Nil Nil )
)<!--												
                                    --></code></pre>
          </li>
          <li>
            Test auf Baum-Gleichheit
            <pre><code><!--
-->equal :: BinTree -> BinTree -> Bool
equal Nil              Nil              = True
equal Nil              (Branch y l2 r2) = False
equal (Branch x l1 r1) Nil              = False
equal (Branch x l1 r1) (Branch y l2 r2) = (x == y) && (equal l1 l2) && (equal r1 r2) <!--
                                    --></code></pre>
          </li>
          <li>
            Einfügen in einen Suchbaum
            <pre><code><!--
-->insert :: BinTree -> [Int] -> BinTree
insert t     [] = t
insert t (x:xs) = insert t' xs
where t' = insertSingle t x
insertSingle Nil            x = Branch x Nil Nil
insertSingle (Branch y l r) x
| x < y     = Branch y (insertSingle l x) r
| otherwise = Branch y l                  (insertSingle r x)<!--
                                    --></code></pre>
          </li>
        </ol>
      </li>
    </ul>
  </details>
</li>

      </ul>
    </div>
  </details>
    
  <details>
    <summary>
      <div class="title">Woche 3: Haskell - Funktionen höherer Ordnung</div>
      <div class="subtitle">26.04. bis 30.04.2021</div>
    </summary>

    <div class="exercise-content">
      <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/videos/e-learning/prog-03-98799wX6.mp4" target="_blank">Vorlesungsvideo</a>
        </li>

        <li>
          <i class="fa-li fa fa-pen"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/tut03.pdf" target="_blank">Übungsblatt 3</a>
        </li>

        
        <li>
          <i class="fa-li fa fa-code"></i>
          <a href="tut.templates"
            >Coding Templates <span class="icon solid fa-download"></span
          ></a>
        </li>
        

        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut03-mi.mp4" target="_blank">
            Videoaufzeichnung der Übung
          </a>
        </li>

        <li>
          <i class="fa-li fa fa-edit"></i>
          <div style="text-align: left">
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03.pdf" class="button primary">Slides</a>
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_handout.pdf" class="button">Handout</a>

             &nbsp;&nbsp;&nbsp;
            <a
              href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_code.zip"
              target="_blank"
              class="button icon solid fa-download"
            >
              Code
            </a>
            
          </div>
        </li>

        <li>
  <ul>
    <li>
      ausführliche Erklärung zu
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_higherOrderFunctions.pdf"
        >Funktionen höherer Ordnung</a
      >
      incl. Erklärung zu Aufgaben 2 und 3
    </li>
    <li>
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut03-aufgabe3.mp4"
        target="_blank"
        >Video zu Aufgabe 3</a
      >
      (<code>foldleft</code>-Funktion)
    </li>
    <li>
      Slides mit Anmerkungen vom
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_notes_di.pdf"
        >Dienstag</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut03/tut03_notes_mi.pdf"
        >Mittwoch</a
      >
    </li>
  </ul>
</li>

<li>
  <i class="fa-li fa fa-edit"></i>
  <details>
    <summary class="inline">Lösungen</summary>

    <ul>
      <li>
        <strong>Aufgabe 1</strong>: Bäume mit beliebig vielen Kindern -
        <code>data RoseTree = Node Int [RoseTree]</code>
        <ol>
          <li>
            Anzahl der Blätter zählen:
            <pre><code><!--
-->countLeaves :: RoseTree -> Int
countLeaves (Node _ [] )    = 1
countLeaves (Node _ [t])    = countLeaves t
countLeaves (Node x (t:ts)) = countLeaves t + countLeaves (Node x ts)<!--
                        --></code></pre>
          </li>
          <li>
            Prüfen, ob ein RoseTree immer eine gerade Anzahl an Kindern hat
            <br />
            <p style="text-align: justify">
              Variante 1: durch Abspalten von immer zwei Bäumen aus der Liste
              können wir am Ende feststellen, ob die Liste gerade Länge (es
              bleibt <code>[]</code> übrig) oder ungerade Länge (es bleibt eine
              einelementige Liste <code>[t]</code> übrig) hatte
            </p>
            <pre><code><!--
-->evenNodes :: RoseTree -> Bool
evenNodes (Node _  []       ) = True
evenNodes (Node x  [t]      ) = False
evenNodes (Node x (t1:t2:ts)) = evenNodes (Node x ts) && evenNodes t1 && evenNodes t2<!--
                        --></code></pre>
            <p style="text-align: justify">
              Variante 2: Wir prüfen explizit, ob die Länge der Liste gerade ist
              (mittels <code>length</code>-Funktion) und testen das erste
              Listenelement mit <code>evenNodes'</code>, die
              <code>RoseTree</code> verarbeiten kann, sowie die Restliste mit
              einer Funktion <code>evenNodes''</code>, die Listen
              <code>[RoseTree]</code> verarbeiten kann.
            </p>
            <pre><code><!--
-->evenNodes' :: RoseTree -> Bool
evenNodes' (Node _ []) = True
evenNodes' (Node _ ts) = mod (length ts) 2 == 0 && evenNodes'' ts
where
evenNodes'' :: [RoseTree] -> Bool
evenNodes'' []     = True
evenNodes'' (t:ts) = evenNodes' t && evenNodes'' ts<!--
                        --></code></pre>
          </li>
        </ol>
      </li>
      <li>
        <strong>Aufgabe 2:</strong> Funktionen höherer Ordnung
        <p style="text-align: justify">
          Für diese Aufgabe gibt es viele verschiedene Varianten, ich erwähne
          hier nur einige davon. Entgegen meiner Behauptung in den Übungen
          benötigt man natürlich beim Filtern der geraden Zahlen keine
          <code>length</code>-Funktion; da hab ich mich von den
          <code>evenNodes</code> von oben verwirren lassen ;)
        </p>
        <pre><code><!--
-->f :: [Int] -> Int
f xs = foldr product 1 (map square (filter even' xs))
where even' x = mod x 2 == 0
square x = x * x
product x y = x * y

f' :: [Int] -> Int
f' xs = foldr (*) 1 (map (^2) (filter even xs))

f'' :: [Int] -> Int
f'' = foldr (*) 1 . map (^2) . filter even

f''' :: [Int] -> Int
f''' = foldr (*) 1 . map (^2) . filter ((== 0) . (`mod` 2))<!--
                --></code></pre>
      </li>
      <li>
        <strong>Aufgabe 3:</strong> Faltung einer Liste von links
        <pre><code><!--
-->foldleft :: (Int -> Int -> Int) -> Int -> [Int] -> Int
foldleft f x []     = x
foldleft f x (y:ys) = foldleft f (f x y) ys<!--												
                --></code></pre>
      </li>
    </ul>
  </details>
</li>

      </ul>
    </div>
  </details>
    
  <details>
    <summary>
      <div class="title">Woche 4: Haskell - Typpolymorphie und Unifikation</div>
      <div class="subtitle">03.05. bis 07.05.2021</div>
    </summary>

    <div class="exercise-content">
      <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/videos/e-learning/prog-04-f1549r84.mp4" target="_blank">Vorlesungsvideo</a>
        </li>

        <li>
          <i class="fa-li fa fa-pen"></i>
          <a href="https://www.orchid.inf.tu-dresden.de/teaching/2021ss/prog/tut04.pdf" target="_blank">Übungsblatt 4</a>
        </li>

        
        <li>
          <i class="fa-li fa fa-code"></i>
          <a href="tut.templates"
            >Coding Templates <span class="icon solid fa-download"></span
          ></a>
        </li>
        

        <li>
          <i class="fa-li fa fa-video"></i>
          <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/video/tut04-di.mp4" target="_blank">
            Videoaufzeichnung der Übung
          </a>
        </li>

        <li>
          <i class="fa-li fa fa-edit"></i>
          <div style="text-align: left">
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04.pdf" class="button primary">Slides</a>
            <a href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_handout.pdf" class="button">Handout</a>

             &nbsp;&nbsp;&nbsp;
            <a
              href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_solution.hs"
              target="_blank"
              class="button icon solid fa-download"
            >
              Code
            </a>
            
          </div>
        </li>

        <li>
  <ul>
    <li>
      Mitschriften vom Dienstag:
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_notes-di-slides.pdf"
        >Slides</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_notes-di-notebook.pdf"
        >Notizbuch</a
      >
    </li>
    <li>
      Mitschriften vom Mittwoch:
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_notes-mi-slides.pdf"
        >Slides</a
      >
      und
      <a
        href="https://wwwpub.zih.tu-dresden.de/~s8071551/programmierung-ss21/tut04/tut04_notes-mi-notebook.pdf"
        >Notizbuch</a
      >
    </li>
  </ul>
</li>
<li>
  <i class="fa-li fa fa-edit"></i>
  <details>
    <summary class="inline">Lösungen - Aufgabe 1</summary>

    Wir betrachten den polymorphen Datentyp
    <code
      >data BinTree a = Branch a (BinTree a) (BinTree a) | Leaf a deriving
      Show</code
    >.
    <ol>
      <li>
        Beispielbaum
        <pre><code><!--
-->testTree :: BinTree Int
testTree = Branch 5
(Leaf 1)
(Branch 12
(Branch 4
(Leaf 0)
(Leaf 0))
(Branch 12
(Leaf 0)
(Leaf 1)))<!--
                            --></code></pre>
      </li>
      <li>
        minimale Tiefe eines Baumes
        <pre><code><!--
-->depth :: BinTree a -> Int
depth (Leaf   _    ) = 1
depth (Branch _ l r) = 1 + min (depth l) (depth r)
-- Hinweis: Die Funktion min ist in der Haskell-Standardbibliothek vorhanden<!--
                            --></code></pre>
      </li>
      <li>
        Beschriftungen eines Baumes durch Beschriftungsfolge ersetzen
        <pre><code><!--
-->paths :: BinTree a -> BinTree [a]
paths = go []
where go :: [a] -> BinTree a -> BinTree [a]
go prefix (Leaf   x    ) = Leaf   (prefix ++ [x])
go prefix (Branch x l r) = Branch (prefix ++ [x]) (go (prefix ++ [x]) l) (go (prefix ++ [x]) r)<!--
                            --></code></pre>
      </li>
      <li>
        <code>map</code>-Funktion für Bäume
        <pre><code><!--
-->tmap :: (a -> b) -> BinTree a -> BinTree b
tmap f (Leaf   x    ) = Leaf   (f x)
tmap f (Branch x l r) = Branch (f x) (tmap f l) (tmap f r)<!--
                            --></code></pre>
      </li>
    </ol>
  </details>

  <details>
    <summary class="inline">Lösungen - Aufgabe 2</summary>

    Das Folgende sind nur kurze Lösungen, die ausführlicheren Lösungen findet
    ihr in den Slides bzw. den Mitschriften der Übung.

    <ul>
      <li>
        <strong>Teil (a):</strong>
        \begin{align*} \definecolor{highlight}{rgb}{.96,.57,0}
        \newcommand{\col}[1]{\textcolor{highlight}{#1}}
        &\left\{\left(\begin{array}{lcrlcl} \col{\sigma(}\sigma(&x_1&,\alpha)
        \col{,} &\ \sigma(&\gamma(x_3) &, x_3)\col{)} \\ \col{\sigma(}\sigma(
        &\gamma(x_2)&,\alpha) \col{,} &\ \sigma(&x_2 &, x_3)\col{)}
        \end{array}\right)\right\}\\ %
        \overset{\text{Dek.}}{\Longrightarrow}\quad %
        &\left\{\left(\begin{array}{lcr} \col{\sigma(} & x_1 & \col{,}
        \alpha\col{)} \\ \col{\sigma(} & \gamma(x_2) & \col{,} \alpha\col{)}
        \end{array}\right), \left(\begin{array}{lcr} \col{\sigma(}& \gamma(x_3)
        & \col{,} x_3)\col{)} \\ \col{\sigma(}& x_2 & \col{,} x_3)\col{)}
        \end{array}\right)\right\} \\ \overset{\text{Dek.}}{\Longrightarrow^2}
        \quad % &\left\{ \begin{pmatrix} x_1 \\ \gamma(x_2) \end{pmatrix} ,
        \begin{pmatrix} \alpha \\ \alpha \end{pmatrix} , \begin{pmatrix}
        \gamma(x_3) \\ x_2 \end{pmatrix} , \col{\begin{pmatrix} x_3 \\ x_3
        \end{pmatrix}} \right\} \\ \overset{\text{El.}}{\Longrightarrow} \quad %
        &\left\{ \begin{pmatrix} x_1 \\ \gamma(x_2) \end{pmatrix} ,
        \col{\begin{pmatrix} \alpha \\ \alpha \end{pmatrix}} , \begin{pmatrix}
        \gamma(x_3) \\ x_2 \end{pmatrix} \right\} \\
        \overset{\text{Dek.}}{\Longrightarrow} \quad % &\left\{ \begin{pmatrix}
        x_1 \\ \gamma(x_2) \end{pmatrix} , \col{\begin{pmatrix} \gamma(x_3) \\
        x_2 \end{pmatrix}} \right\} \\ \overset{\text{Vert.}}{\Longrightarrow}
        \quad % &\left\{ \begin{pmatrix} x_1 \\ \gamma(\col{x_2}) \end{pmatrix}
        , \begin{pmatrix} \col{x_2} \\ \gamma(x_3) \end{pmatrix} \right\} \quad
        ({\text{Occur check: } \textcolor{cdgray}{x_2 \text{ kommt nicht in }
        \gamma(x_3) \text{ vor}}})\\ % \overset{\text{Subst.}}{\Longrightarrow}
        \quad &\left\{ \begin{pmatrix} x_1 \\ \gamma(\gamma(x_3)) \end{pmatrix}
        , \begin{pmatrix} x_2 \\ \gamma(x_3) \end{pmatrix} \right\} \end{align*}
        allgemeinster Unifikator: \begin{align*} x_1 &\mapsto
        \gamma(\gamma(x_3)) \\ x_2 &\mapsto \gamma(x_3) \\ x_3 &\mapsto x_3
        \end{align*}
      </li>
      <li>
        <strong>Teil (b):</strong>
        Zwei weitere Unifikatoren finden wir durch die konkrete Belegung der
        "freien" Variable \(x_3\): \begin{align*} x_1 &\mapsto
        \gamma(\gamma(\alpha)) & x_1 &\mapsto \gamma(\gamma(\gamma(\alpha))) \\
        x_2 &\mapsto \gamma(\alpha) & x_2 &\mapsto \gamma(\gamma(\alpha)) \\ x_3
        &\mapsto \alpha & x_3 &\mapsto \gamma(\alpha) \end{align*}
      </li>
      <li>
        <strong>Teil (c):</strong>
        Der Occur check schlägt für die Terme \( t_1 = x_1 \) und \( t_2 =
        \gamma(x_1) \) fehl, da \( x_1 \) in \( t_2 = \gamma(x_1) \) vorkommt.
        Würden wir hier substituieren, liefen wir in eine Endlosrekursion.
      </li>
      <li>
        <strong>Teil (d):</strong>
        Gegeben seien folgende Typausdrücke: \begin{align*} t_1 &= \texttt{(a ,
        [a])} \\ t_2 &= \texttt{(Int , [Double])} \\ t_3 &= \texttt{(b , c)}
        \end{align*}
        <ul>
          <li>\(t_1\) und \(t_2\) sind nicht unifizierbar</li>
          <li>
            \(t_2\) und \(t_3\) sind unifizierbar mit \(\texttt{b} \mapsto
            \texttt{Int}\), \(\texttt{c} \mapsto \texttt{[Double]}\)
          </li>
          <li>
            \(t_1\) und \(t_3\) sind unifizierbar mit \(\texttt{a} \mapsto
            \texttt{a}\), \(\texttt{b} \mapsto \texttt{a}\), \(\texttt{c}
            \mapsto \texttt{[a]}\)
          </li>
        </ul>
      </li>
    </ul>
  </details>
</li>

      </ul>
    </div>
  </details>
   

  <footer>Hier steht section footer text.</footer>
</section>


				</div> <!-- end inner -->

				<footer>
					
				</footer>
			</div> <!-- end main -->

			<!-- Sidebar -->
			<div id="sidebar">
				<div class="inner">

					<!-- Menu -->
					<nav id="menu">
    <header class="major">
        <h2>Menu</h2>
    </header>
    <ul>
        <li><a href="index.html">Home</a></li>
        <li>
            <a href="prog21.html">
                <div class=menu-item-title>Programmierung</div> 
                <div class="menu-item-subtitle">Sommer 2021</div>
            </a>
        </li>
        <li>
            <a href="lag20.html">
                <div class="menu-item-title">Lineare Algebra</div>
                <div class="menu-item-subtitle">Winter 2020/21</div>
            </a>
        </li>
        <li>
            <a href="aud20.html">
                <div class="menu-item-title">Algorithmen & Datenstrukturen</div>
                <div class="menu-item-subtitle">Winter 2020/21</div>
            </a>
        </li>
        <li>
            <a href="index.html#overview">
            <div class="menu-item-title">Früher</div>
            </a>
        </li>
        <!-- <li>
            <span class="opener">Submenu</span>
            <ul>
                <li><a href="#">Lorem Dolor</a></li>
                <li><a href="#">Ipsum Adipiscing</a></li>
                <li><a href="#">Tempus Magna</a></li>
                <li><a href="#">Feugiat Veroeros</a></li>
            </ul>
        </li> -->
    </ul>
</nav>

					<!-- Footer -->
					<footer id="footer">
    <h4><a href="impressum.html">Impressum</a></h4>
    <p class="copyright">&copy; Eric Kunze. All rights reserved.<br>
        Images: <a href="https://unsplash.com">Unsplash</a> <br>
        Design: <a href="https://html5up.net">HTML5 UP</a>.
    </p>
</footer>

				</div> <!-- end inner -->
			</div> <!-- end sidebar -->

		</div> <!-- end wrapper -->

		<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>
	</body>
</html>